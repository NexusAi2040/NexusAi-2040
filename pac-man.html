<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=560, initial-scale=1.0">
  <title>Notorious Squirrel</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: 30px auto;
      background-color: #111;
      border: 5px solid #0f0;
    }
    #overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #AAFF00;
      font-family: monospace;
      font-size: 24px;
      background: rgba(0, 0, 0, 0.75);
      padding: 20px;
      border: 2px solid #0f0;
      z-index: 10;
      text-align: center;
      cursor: pointer;
    }
    #restart-btn {
      display: none;
      position: absolute;
      top: 60%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #AAFF00;
      color: #000;
      font-family: monospace;
      font-size: 18px;
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      z-index: 11;
    }
    #countdown {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 64px;
      font-family: monospace;
      color: #FF00FF;
      z-index: 12;
    }
  </style>
</head>
<body>
<div id="overlay">PRESS SPACE TO START</div>
<div id="countdown">3</div>
<button id="restart-btn" onclick="location.reload()">RESTART GAME</button>
<canvas id="gameCanvas" width="560" height="620"></canvas>
<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const overlay = document.getElementById("overlay");
  const restartBtn = document.getElementById("restart-btn");
  const countdown = document.getElementById("countdown");

  const tileSize = 20;
  let gameStarted = false;
  let gameOverState = false;
  let lastMoveTime = 0;
  const moveDelay = 1000;

  const maze = [
    "############################",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#o####.#####.##.#####.####o#",
    "#.####.#####.##.#####.####.#",
    "#..........................#",
    "#.####.##.########.##.####.#",
    "#.####.##.########.##.####.#",
    "#......##....##....##......#",
    "######.##### ## #####.######",
    "######.##### ## #####.######",
    "######.##          ##.######",
    "######.## ######## ##.######",
    "######.## ######## ##.######",
    "######.## ######## ##.######",
    "######.## ######## ##.######",
    "######.##          ##.######",
    "######.## ######## ##.######",
    "######.## ######## ##.######",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#.####.#####.##.#####.####.#",
    "#o..##................##..o#",
    "###.##.##.########.##.##.###",
    "###.##.##.########.##.##.###",
    "#......##....##....##......#",
    "#.##########.##.##########.#",
    "#..........................#",
    "############################"
  ];

  let squirrel = { x: 1, y: 1, dx: 0, dy: 0 };
  let score = 0;

  const guards = [];
  for (let i = 0; i < 4; i++) {
    let gx, gy, attempts = 0;
    do {
      gx = Math.floor(Math.random() * maze[0].length);
      gy = Math.floor(Math.random() * maze.length);
      attempts++;
      if (attempts > 100) break; // safety net
    } while (maze[gy][gx] === '#' || guards.some(g => g.x === gx && g.y === gy));

    if (maze[gy][gx] !== '#') {
      guards.push({
        x: gx,
        y: gy,
        dx: 0,
        dy: 0,
        color: `hsl(${Math.floor(Math.random() * 360)}, 100%, 50%)`
      });
    }
  }

  function drawMaze() {
    for (let y = 0; y < maze.length; y++) {
      for (let x = 0; x < maze[y].length; x++) {
        const char = maze[y][x];
        if (char === '#') {
          ctx.fillStyle = "#00FF00";
          ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
        } else if (char === '.') {
          ctx.fillStyle = "#AA00FF";
          ctx.beginPath();
          ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, 3, 0, Math.PI * 2);
          ctx.fill();
        } else if (char === 'o') {
          ctx.fillStyle = "#FFFF00";
          ctx.beginPath();
          ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  function drawSquirrel() {
    ctx.fillStyle = "yellow";
    ctx.beginPath();
    ctx.arc(squirrel.x * tileSize + tileSize / 2, squirrel.y * tileSize + tileSize / 2, 8, 0.25 * Math.PI, 1.75 * Math.PI);
    ctx.lineTo(squirrel.x * tileSize + tileSize / 2, squirrel.y * tileSize + tileSize / 2);
    ctx.fill();
  }

  function drawGuards() {
    for (const guard of guards) {
      if (!guard) continue;
      ctx.fillStyle = guard.color;
      ctx.beginPath();
      ctx.arc(guard.x * tileSize + tileSize / 2, guard.y * tileSize + tileSize / 2, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.arc(guard.x * tileSize + tileSize / 2 - 3, guard.y * tileSize + tileSize / 2 - 2, 2, 0, Math.PI * 2);
      ctx.arc(guard.x * tileSize + tileSize / 2 + 3, guard.y * tileSize + tileSize / 2 - 2, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function moveGuards() {
    for (const guard of guards) {
      if (!guard) continue;
      const dx = squirrel.x - guard.x;
      const dy = squirrel.y - guard.y;
      const moveOptions = [];

      if (dx !== 0) moveOptions.push({ dx: Math.sign(dx), dy: 0 });
      if (dy !== 0) moveOptions.push({ dx: 0, dy: Math.sign(dy) });

      for (let i = moveOptions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [moveOptions[i], moveOptions[j]] = [moveOptions[j], moveOptions[i]];
      }

      let moved = false;
      for (const move of moveOptions) {
        const newX = guard.x + move.dx;
        const newY = guard.y + move.dy;
        if (maze[newY]?.[newX] !== '#') {
          guard.x = newX;
          guard.y = newY;
          guard.dx = move.dx;
          guard.dy = move.dy;
          moved = true;
          break;
        }
      }

      if (!moved) {
        const dirs = [
          { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
          { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
        ];
        const options = dirs.filter(d => maze[guard.y + d.dy]?.[guard.x + d.dx] !== '#');
        const pick = options[Math.floor(Math.random() * options.length)];
        if (pick) {
          guard.x += pick.dx;
          guard.y += pick.dy;
          guard.dx = pick.dx;
          guard.dy = pick.dy;
        }
      }

      if (guard.x === squirrel.x && guard.y === squirrel.y) {
        endGame();
      }
    }
  }

  function update() {
    const newX = squirrel.x + squirrel.dx;
    const newY = squirrel.y + squirrel.dy;
    if (maze[newY]?.[newX] && maze[newY][newX] !== '#') {
      squirrel.x = newX;
      squirrel.y = newY;
      const row = maze[squirrel.y];
      const tile = row[squirrel.x];
      if (tile === '.' || tile === 'o') {
        score += tile === 'o' ? 10 : 1;
        maze[squirrel.y] = row.substring(0, squirrel.x) + ' ' + row.substring(squirrel.x + 1);
      }
    }
  }

  function gameLoop(timestamp) {
    if (!gameStarted || gameOverState) return;
    if (!lastMoveTime) lastMoveTime = timestamp;
    if (timestamp - lastMoveTime >= moveDelay) {
      update();
      moveGuards();
      lastMoveTime = timestamp;
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawMaze();
    drawSquirrel();
    drawGuards();
    requestAnimationFrame(ts => gameLoop(ts));
  }

  function startCountdown() {
    let count = 3;
    countdown.textContent = count;
    countdown.style.display = "block";
    const interval = setInterval(() => {
      count--;
      if (count > 0) {
        countdown.textContent = count;
      } else {
        clearInterval(interval);
        countdown.style.display = "none";
        startGame();
      }
    }, 1000);
  }

  function startGame() {
    lastMoveTime = 0;
    gameStarted = true;
    gameOverState = false;
    overlay.style.display = "none";
    restartBtn.style.display = "none";
    requestAnimationFrame(ts => gameLoop(ts));
  }

  function endGame() {
    gameOverState = true;
    restartBtn.style.display = "block";
  }

  function setDirection(dx, dy) {
    squirrel.dx = dx;
    squirrel.dy = dy;
  }

  document.addEventListener("keydown", (e) => {
    if (!gameStarted && e.code === "Space") startCountdown();
    if (gameStarted && !gameOverState) {
      if (e.key === "ArrowUp") setDirection(0, -1);
      else if (e.key === "ArrowDown") setDirection(0, 1);
      else if (e.key === "ArrowLeft") setDirection(-1, 0);
      else if (e.key === "ArrowRight") setDirection(1, 0);
    }
  });

  overlay.addEventListener("click", startCountdown);
</script>
</body>
</html>
