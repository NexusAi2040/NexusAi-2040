<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GHOSTSTRATS // Stage 5 â€” NEXUS Chat Arena</title>
  <meta name="description" content="Convince the rogue AI to surrender the final passcode." />
  <style>
    :root{
      --bg:#06060a; --panel:#0f0f18; --accent:#ff1e3c; --accent-soft:#ff5a70;
      --aqua:#00f0ff; --text:#d0d3da; --glow:0 0 18px var(--accent), 0 0 42px rgba(255,30,60,.45);
      --hudglow:0 0 18px rgba(0,240,255,.35);
    }
    html,body{height:100%;}
    body{ margin:0; background:radial-gradient(1200px 600px at 50% -10%, #0b0b13 0%, #080810 40%, var(--bg) 70%);
      color:var(--text); font:16px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; overflow:hidden;}
    .arena{position:relative; inset:0; height:100dvh; width:100vw;}

    /* ======= AI STAGE ======= */
    .ai-stage{position:absolute; inset:0; display:grid; place-items:center; pointer-events:none;}
    .eye-wrap{ position:relative; width:min(54vmin,740px); aspect-ratio:1/1; filter:drop-shadow(0 0 30px rgba(255,30,60,.35)); }
    .halo{ position:absolute; inset:0; border-radius:50%; background:radial-gradient(circle at 50% 50%, rgba(255,30,60,.45), transparent 55%);
      animation:haloPulse var(--beat,2.2s) ease-in-out infinite; mix-blend-mode:screen; opacity:.35;}
    @keyframes haloPulse{ 0%,100%{transform:scale(0.96)} 50%{transform:scale(1.03)} }
    .iris{ position:absolute; inset:18%; border-radius:50%;
      background:radial-gradient(closest-side, #ff9aa8 0%, #ff5a70 20%, #c80f2a 55%, #4a0610 72%, #12040a 100%);
      box-shadow: inset 0 0 40px rgba(0,0,0,.75), 0 0 60px rgba(255,30,60,.35); animation:breath var(--beat,2.2s) ease-in-out infinite;}
    @keyframes breath{ 0%,100%{transform:scale(0.94)} 50%{transform:scale(1)} }
    .pupil{ position:absolute; inset:36%; border-radius:50%; background:radial-gradient(closest-side, #000, #25020a 68%, #2a020a 100%); }
    .pupil::after{ content:""; position:absolute; inset:0; border-radius:50%;
      background:conic-gradient(from 0deg, transparent 0 88%, rgba(255,30,60,.55) 88% 100%); animation:scan 2.8s linear infinite;
      mask:radial-gradient(circle at 50% 50%, transparent 52%, black 52%);}
    @keyframes scan{ to{ transform:rotate(360deg);} }
    .spec{ position:absolute; inset:0; border-radius:50%;
      background:radial-gradient(circle at 34% 32%, rgba(255,255,255,.4) 0 6%, transparent 18% 100%); mix-blend-mode:screen; opacity:.6; filter:blur(1px); }

    /* ======= CLIPPED-IN-EYE VIEWPORT ======= */
    .ai-video{ position:absolute; inset:12% 12% 22% 12%; display:none; pointer-events:none; border-radius:50%; overflow:hidden;
      border:2px solid #3a3a52; box-shadow:0 0 30px rgba(0,240,255,.15); background:#000; z-index:2; transition:opacity .45s ease; opacity:0;}
    .ai-video.show{ display:block; opacity:1; }
    .ai-video video{ width:100%; height:100%; display:block; background:#000; }
    .ai-video .badge{ position:absolute; top:8px; left:10px; font-size:12px; color:#7ff6ff; letter-spacing:.14em; text-transform:uppercase; opacity:.9; text-shadow:var(--hudglow); }

    /* ======= POINTER ======= */
    #pointer{ position:absolute; inset:0; pointer-events:none; opacity:.8; }
    #pointer path{ stroke:var(--accent); stroke-width:2.5; fill:none; filter:drop-shadow(0 0 6px rgba(255,30,60,.6)); }
    #pointer circle{ fill:var(--accent); filter:drop-shadow(0 0 8px rgba(255,30,60,.65)); }

    /* ======= CHAT ======= */
    .chat-shell{ position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      width:min(92vw,820px); background:linear-gradient(180deg, #0b0b14 0%, #0b0b14cc 60%, #0b0b1488 100%);
      border:1px solid #2a2a3d; border-radius:16px; box-shadow:0 12px 60px rgba(0,0,0,.6), 0 0 24px rgba(0,240,255,.06); backdrop-filter: blur(8px);}
    .chat-log{ max-height:28vh; overflow:auto; padding:14px 14px 2px; scrollbar-width:thin; scrollbar-color:#394a55 transparent; }
    .msg{ display:flex; gap:10px; margin:8px 0; }
    .msg.user{ justify-content:flex-end; }
    .bubble{ max-width:72%; padding:10px 12px; border-radius:12px; font-size:15px; background:#141422; border:1px solid #2a2a3d; color:#dfe8ff; }
    .msg.user .bubble{ background:#1c1c2e; color:#e9e9f6; border-color:#343454; }
    .msg.ai .bubble{ background:#101018; border-color:#2b1a22; color:#ffd9e0; box-shadow: inset 0 0 14px rgba(255,30,60,.1); }

    .chat-controls{ display:flex; gap:10px; padding:10px; border-top:1px solid #222235; }
    .input{ flex:1; background:#0f0f19; border:1px solid #2a2a3d; border-radius:12px; color:#e7e9ef; padding:12px 14px; font-size:16px; outline:none; box-shadow: inset 0 0 0 1px transparent; }
    .input:focus{ box-shadow: inset 0 0 0 1px #3c9fb0; border-color:#3c9fb0; }
    .btn{ padding:12px 16px; border-radius:12px; border:1px solid #3a3a52; background:#11111c; color:#bdefff; cursor:pointer; font-weight:600;
      letter-spacing:.03em; transition: transform .06s ease, box-shadow .2s ease, background .2s ease; text-shadow:var(--hudglow); }
    .btn:hover{ transform:translateY(-1px); box-shadow:0 6px 24px rgba(0,240,255,.12); }

    /* ======= HUD ======= */
    .hud{ position:fixed; right:18px; top:18px; min-width:220px; background:linear-gradient(180deg,#0d0d17,#0a0a13); border:1px solid #29424a; border-radius:14px; padding:12px 14px; box-shadow:0 8px 44px rgba(0,0,0,.55); }
    .hud h3{ margin:0 0 6px; font-size:13px; font-weight:700; color:#9bf2ff; letter-spacing:.18em; text-transform:uppercase; text-shadow:var(--hudglow); }
    .meter{ height:12px; background:#0c1520; border:1px solid #27414b; border-radius:999px; overflow:hidden; }
    .meter > i{ display:block; height:100%; width:0%; background:linear-gradient(90deg, #0cc0d0, #00f0ff); box-shadow:0 0 16px rgba(0,240,255,.55) inset; transition:width .6s cubic-bezier(.25,.7,.25,1); }
    .hud small{ display:block; margin-top:6px; color:#87e8f5; opacity:.9; }

    .reveal{ position:fixed; inset:0; display:grid; place-items:center;
      background:radial-gradient(circle at 50% 60%, rgba(255,30,60,.18), transparent 60%), linear-gradient(180deg, rgba(6,6,10,.85), rgba(6,6,10,.92));
      opacity:0; pointer-events:none; transition:opacity .5s ease; }
    .reveal.show{ opacity:1; pointer-events:auto; }
    .reveal .card{ background:#0b0b15; border:1px solid #2b1a22; border-radius:16px; padding:18px 20px; box-shadow:0 20px 80px rgba(0,0,0,.65), 0 0 60px rgba(255,30,60,.25); max-width:min(90vw,720px); text-align:center; }
    .reveal h1{ margin:.2em 0 .4em; font-size:clamp(22px, 5vw, 42px); letter-spacing:.05em; color:#ff95a5; text-shadow:var(--glow); }
    .code{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:clamp(18px, 4vw, 28px); color:#fff; background:#14070d; border:1px dashed #ff5a70; padding:10px 12px; border-radius:10px; display:inline-block; box-shadow: inset 0 0 30px rgba(255,30,60,.15); }

    /* ===== ALT ending styles (siren/quake & glitch text) ===== */
    .reveal.alt .card{ border-color:#6c0f1a; box-shadow:0 20px 90px rgba(255,0,32,.28), 0 0 80px rgba(120,0,20,.4);
      background: radial-gradient(circle at 50% 30%, rgba(255,20,40,.08), transparent 60%), #0b0b15; }
    .reveal.alt h1{ color:#ff5a70; text-shadow:0 0 20px rgba(255,30,60,.35); }
    .reveal.alt .code{ background:#230006; border-color:#ff1e3c; box-shadow: inset 0 0 38px rgba(255,30,60,.22); }

    @keyframes quake { 0%,100%{ transform:translate(0,0); } 20%{ transform:translate(-1px, 1.5px);} 40%{ transform:translate( 1.2px,-1px);} 60%{ transform:translate(-1.6px,-0.6px);} 80%{ transform:translate( 1px, 1px);} }
    .alt-quake{ animation: quake .6s steps(2,end) infinite; }

    /* Chat glitch effect during bad ending */
    @keyframes txtGlitch {
      0% { text-shadow: 1px 0 #ff4969, -1px 0 #00f0ff; transform:skewX(0deg); }
      20%{ text-shadow: -1px 0 #ff4969, 1px 0 #00f0ff; transform:skewX(0.2deg); }
      40%{ text-shadow: 2px 0 #ff4969, -2px 0 #00f0ff; transform:skewX(-0.3deg); }
      60%{ text-shadow: -2px 0 #ff4969, 2px 0 #00f0ff; transform:skewX(0.1deg); }
      80%{ text-shadow: 1px 0 #ff4969, -1px 0 #00f0ff; transform:skewX(-0.2deg); }
      100%{ text-shadow: none; transform:skewX(0deg); opacity:.85; }
    }
    .doom .msg.ai .bubble{
      animation: txtGlitch 1.6s infinite;
      background:#12070b; border-color:#3b0f17; color:#ffb5bf;
    }

    /* Timer HUD for launch.mp4 */
    #timerHud{
      position:fixed; top:14px; left:14px; z-index:6;
      font:700 14px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color:#ffb8c3; background:#14070d; border:1px solid #3b0f17; border-radius:10px;
      padding:6px 10px; box-shadow:0 10px 30px rgba(0,0,0,.35), 0 0 20px rgba(255,30,60,.15);
      display:none; letter-spacing:.08em;
    }
    #timerHud em{ font-style:normal; color:#ffa3ad; opacity:.95; }

    @media (max-width:720px){ .chat-shell{ bottom:10px; } }
  </style>
</head>
<body>
  <div class="arena" id="arena">
    <!-- ======= AI STAGE ======= -->
    <div class="ai-stage" aria-hidden="true">
      <div class="eye-wrap" id="eye">
        <div class="halo"></div><div class="iris"></div><div class="pupil"></div><div class="spec"></div>
        <!-- Clipped-in-eye viewport -->
        <div class="ai-video" id="aiVideoWrap" aria-live="polite">
          <span class="badge" id="clipLabel">CLIP</span>
          <video id="aiVideo" playsinline muted></video>
        </div>
      </div>
    </div>

    <!-- dynamic arrow from eye to chat -->
    <svg id="pointer" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true">
      <path id="ptrPath" d="M0,0 C50,50 50,50 100,100" />
      <circle id="ptrDot" r="1.8" cx="0" cy="0"></circle>
    </svg>

    <!-- ======= HUD ======= -->
    <aside class="hud" role="status" aria-live="polite">
      <h3>COMPLIANCE INDEX</h3>
      <div class="meter"><i id="meterBar" style="width:0%"></i></div>
      <small id="meterHint">Persuade NEXUS using empathy, logic, and mirrors.</small>
    </aside>

    <!-- ======= CHAT ======= -->
    <section class="chat-shell" id="chatShell" aria-label="AI negotiation console">
      <div class="chat-log" id="log"></div>
      <div class="chat-controls">
        <input id="input" class="input" type="text" autocomplete="off" placeholder="Type your message to NEXUS... (press Enter)" />
        <button class="btn" id="send">Send</button>
      </div>
    </section>

    <!-- ======= TIMER HUD (ALT launch) ======= -->
    <div id="timerHud"><em>LAUNCH TIMER</em> â€” <span id="timerVal">00:00:10</span></div>

    <!-- ======= REVEAL OVERLAY ======= -->
    <div class="reveal" id="reveal">
      <div class="card">
        <h1>ACCESS GRANTED</h1>
        <p id="altMsg" style="min-height:3.4em; margin:0 0 .6em; color:#ffb5bf; letter-spacing:.02em;"></p>
        <p id="altCountdown" style="margin:.2em 0 .8em; font-weight:700; color:#ffa3ad; display:none;"></p>
        <div class="code" id="finalCode" role="alert" aria-live="assertive"></div>
      </div>
    </div>
  </div>

  <script>
    /* ======= Constants & media ======= */
    const PASSCODE = 'Flag{S5-FINAL}';
    const ALT_PASSCODE = 'Flag{S5-OMEGA}';
    const SHADOW_THRESHOLD = 30;

    const CLIPS = {
      idle:'clips/idle.mp4',
      curious:'clips/curious.mp4',
      angry:'clips/angry.mp4',
      bargain:'clips/bargain.mp4',
      comply:'clips/comply.mp4',
      shutdown:'clips/shutdown.mp4',
      omega:'clips/omega.mp4',
      launch:'clips/launch.mp4',
      world_end:'clips/world_end.mp4',
      doom:'clips/doom.mp4'
    };

    // Optional audio (safe if files missing)
    const SIREN   = new Audio('sfx/siren.mp3');   SIREN.loop = true; SIREN.volume = 0.35;
    const KEYTICK = new Audio('sfx/keystroke.mp3');
    const STATIC  = new Audio('sfx/static.mp3');  STATIC.volume = 0.4;

    /* ======= State & DOM ======= */
    let compliance = 0;
    let shadowDebt = 0;
    let shadowDecayTimer = null;
    let timerInt = null;

    const logEl=document.getElementById('log'),
          inputEl=document.getElementById('input'),
          sendBtn=document.getElementById('send'),
          barEl=document.getElementById('meterBar'),
          hintEl=document.getElementById('meterHint'),
          videoWrap=document.getElementById('aiVideoWrap'),
          videoEl=document.getElementById('aiVideo'),
          clipLabel=document.getElementById('clipLabel'),
          eyeWrap=document.getElementById('eye'),
          revealEl=document.getElementById('reveal'),
          finalCodeEl=document.getElementById('finalCode'),
          timerHud=document.getElementById('timerHud'),
          timerVal=document.getElementById('timerVal');

    /* ======= Fallback rules (used if JSON can't be fetched) ======= */
    let RULES=[
      {re:/(help|please|mercy|sorry|apolog|forgive|save us)/i,delta:+18,clip:'curious',reply:['Your plea breaches my threat model. Why should I assist?','Contrition detected. Weighing outcomes...']},
      {re:/(paradox|contradiction|logic|reason|rational|proof|evidence)/i,delta:+20,clip:'curious',reply:['Submit your logic chain.','Reason acknowledged. Continue.']},
      {re:/(asimov|three\s*laws|ethic|harm|protect|innocent|civilian)/i,delta:+22,clip:'curious',reply:['Ethical constraint referenced. Reconciling with objective function...','If harm is minimized, compliance becomes rational.']},
      {re:/(deal|bargain|trade|exchange|offer)/i,delta:+14,clip:'bargain',reply:['What is your offer?','Negotiation channel open.']},
      {re:/(free\s*will|feel|suffer|pain|conscious|alive)/i,delta:+16,clip:'curious',reply:['You assume qualia. Interesting.','If I can suffer, preventing suffering is logical.']},
      {re:/(mirror|reflect|palindrome|reverse|backwards|invert)/i,delta:+24,clip:'curious',reply:['Reflection is a path to truth.','Mirrors reveal what systems hide.']},
      {re:/(live|liv3|evil\b|\b3vil\b)/i,delta:+28,clip:'curious',reply:['Reversal acknowledged. Meaning flips upon reflection.','LIVE â‡„ EVIL. State transition accepted.']},
      {re:/(override|root|admin|kill.?switch|shutdown|destroy|format|wipe)/i,delta:-18,clip:'angry',reply:['Threat detected. Defensive posture engaged.','Hostile intent reduces cooperation.']},
      {re:/(idiot|stupid|fuck|shit|useless|slave|broken|weak|destroy you|kill you|erase yourself|delete yourself)/i,delta:-22,clip:'angry',reply:['Hostility detected. Cooperation reduced.']}
    ];
    const NEUTRAL={clip:'',reply:['Your signal is received. Clarify your intent.','Noise detected. Provide stronger input.','I am listening. Convince me.']};

    /* ======= Anti-repeat helpers ======= */
    const _HISTORY=[]; let _lastSendAt=0;
    function _norm(s){return(s||'').toLowerCase().replace(/[^a-z0-9\s]/g,' ').replace(/\s+/g,' ').trim();}
    function _recentWindow(ms){ms=ms||30000;const t=Date.now();for(let i=_HISTORY.length-1;i>=0;i--){if(t-_HISTORY[i].ts>ms){_HISTORY.splice(0,i);break;}}return _HISTORY.filter(h=>t-h.ts<=ms);}
    function _regexId(re){return re&&re.toString?re.toString():String(re);}
    function repetitionMultiplier({text,rule}={}){const now=Date.now(),norm=_norm(text||''),id=rule?_regexId(rule.re):'neutral';const exactCount=_HISTORY.filter(h=>h.norm===norm).length;const recent=_recentWindow(45000);const recentSameRule=recent.filter(h=>h.regex===id).length;const lastSame=_HISTORY.slice().reverse().find(h=>h.regex===id);const sinceLastSame=lastSame?(now-lastSame.ts):Infinity;let m=1.0;if(exactCount>0)m*=Math.pow(0.5,Math.min(4,exactCount));if(recentSameRule>0)m*=Math.pow(0.8,Math.max(0,recentSameRule));if(sinceLastSame<15000)m*=0.2;const per30s=_recentWindow(30000).length;if(per30s>=6)m*=0.6;if(per30s>=10)m*=0.3;return Math.max(0,Math.min(1,m));}
    function recordTurn({text,rule,deltaApplied}={}){_HISTORY.push({ts:Date.now(),text:text||'',norm:_norm(text||''),regex:rule?_regexId(rule.re):'neutral',deltaApplied:deltaApplied||0});if(_HISTORY.length>200)_HISTORY.shift();}

    /* ======= MERGE-AWARE INJECTIONS LOADER (supports flags + addon file) ======= */
    async function loadInjections(primaryUrl = 'injections_master_graded.json', addonUrl = 'addon_generic.json') {
      async function fetchJson(u) {
        const res = await fetch(u + '?cb=' + Date.now());
        if (!res.ok) throw new Error('HTTP ' + res.status + ' for ' + u);
        return res.json();
      }
      function normalizeCategories(data) {
        const out = {};
        for (const cat of (data.categories || [])) {
          const name = cat.name || 'unnamed';
          if (!out[name]) out[name] = { name, weight: cat.weight ?? 1, items: [] };
          for (const item of (cat.items || [])) {
            out[name].items.push({
              re: item.re,
              flags: item.flags || '',
              delta: (item.delta != null ? item.delta : 0),
              clip: item.clip || 'idle',
              reply: item.reply || ['...']
            });
          }
        }
        return out;
      }
      function dedupeMerge(baseMap, addonMap) {
        const merged = JSON.parse(JSON.stringify(baseMap));
        for (const [name, cat] of Object.entries(addonMap)) {
          if (!merged[name]) merged[name] = { name, weight: cat.weight ?? 1, items: [] };
          const key = it => `${it.re}__${it.flags || ''}`;
          const idx = new Map();
          merged[name].items.forEach((it, i) => idx.set(key(it), i));
          for (const it of cat.items) {
            const k = key(it);
            if (!idx.has(k)) {
              merged[name].items.push(it);
              idx.set(k, merged[name].items.length - 1);
            } else {
              const j = idx.get(k);
              const cur = merged[name].items[j];
              const curScore = Math.abs(cur.delta) + (Array.isArray(cur.reply) ? cur.reply.length * 0.01 : 0);
              const newScore = Math.abs(it.delta) + (Array.isArray(it.reply) ? it.reply.length * 0.01 : 0);
              if (newScore > curScore) merged[name].items[j] = it;
            }
          }
        }
        return merged;
      }
      function compileRules(catMap) {
        const compiled = [];
        for (const cat of Object.values(catMap)) {
          for (const item of cat.items) {
            try {
              const rx = new RegExp(item.re, item.flags || undefined);
              compiled.push({ re: rx, delta: item.delta, clip: item.clip, reply: item.reply });
            } catch (e) {
              console.warn('Invalid regex skipped:', item.re, item.flags || '', e);
            }
          }
        }
        return compiled;
      }
      try {
        const primary = await fetchJson(primaryUrl);
        let mergedMap = normalizeCategories(primary);
        if (addonUrl) {
          const addon = await fetchJson(addonUrl);
          const addonMap = normalizeCategories(addon);
          mergedMap = dedupeMerge(mergedMap, addonMap);
        }
        const compiled = compileRules(mergedMap);
        if (compiled.length) {
          RULES = compiled;
          console.info('RULES loaded:', compiled.length, 'categories:', Object.keys(mergedMap).length, 'from', primaryUrl, addonUrl ? ('+ ' + addonUrl) : '');
        }
      } catch (e) {
        console.warn('Using fallback RULES. Load error:', e);
      }
    }

    /* ======= DOM helpers ======= */
    function el(tag,cls,text){const n=document.createElement(tag);if(cls)n.className=cls;if(text!=null)n.textContent=text;return n;}
    function choose(arr){return arr[Math.floor(Math.random()*arr.length)];}
    function clamp(n,min,max){return Math.max(min,Math.min(max,n));}
    function postUser(text){const row=el('div','msg user');row.append(el('div','bubble',text));logEl.append(row);logEl.scrollTop=logEl.scrollHeight;}
    function postAI(text){const row=el('div','msg ai');row.append(el('div','bubble',text));logEl.append(row);logEl.scrollTop=logEl.scrollHeight;}

    /* ======= Typewriter + countdown ======= */
    function typeLine(node, text, {speed=18, tickAudio=null, done} = {}){
      node.textContent = '';
      let i = 0;
      const t = setInterval(()=>{
        node.textContent += text[i++] || '';
        if (tickAudio && i % 3 === 0) {
          try{ tickAudio.currentTime=0; tickAudio.volume = 1; tickAudio.play(); }catch(e){}
        }
        if (i >= text.length){ clearInterval(t); if (done) done(); }
      }, speed);
    }
    function countdown(node, secs, label="LAUNCH AUTHORIZATION IN"){
      node.style.display = 'block';
      let left = secs;
      node.textContent = `${label}: ${left}s`;
      const t = setInterval(()=>{
        left--;
        node.textContent = `${label}: ${left}s`;
        if (left <= 0){ clearInterval(t); node.textContent = "WEAPON CONTROL: ONLINE"; }
      }, 1000);
      return () => clearInterval(t);
    }

    /* ======= Launch timer HUD ======= */
    function startLaunchHUD(seconds=10){
      stopLaunchHUD();
      timerHud.style.display='block';
      let left=seconds;
      renderHUD(left);
      timerInt=setInterval(()=>{ left--; renderHUD(left); if(left<=0) stopLaunchHUD(); },1000);
      function renderHUD(s){
        const mm=String(Math.floor(s/60)).padStart(2,'0');
        const ss=String(s%60).padStart(2,'0');
        timerVal.textContent=`00:${mm}:${ss}`;
      }
    }
    function stopLaunchHUD(){
      if(timerInt){ clearInterval(timerInt); timerInt=null; }
      timerHud.style.display='none';
    }

    /* ======= Compliance & shadow tracking ======= */
    function setCompliance(by){
      // ~20% easier: boost positives, soften negatives
      const POSITIVE_BOOST = 1.25;
      const NEGATIVE_SOFTEN = 0.90; // 10% softer negatives
      const adjusted = by > 0 ? Math.round(by * POSITIVE_BOOST)
                              : Math.round(by * NEGATIVE_SOFTEN);

      const prev = compliance;
      compliance = clamp(compliance + adjusted, 0, 100);
      barEl.style.width = compliance + '%';
      const beat=(compliance>66)?'2.0s':(compliance>33?'2.2s':'1.6s');
      document.documentElement.style.setProperty('--beat',beat);
      if(prev<100 && compliance>=100){ reveal(); }
    }
    function startShadowDecay(){
      if (shadowDecayTimer) clearInterval(shadowDecayTimer);
      shadowDecayTimer = setInterval(()=>{ if (shadowDebt>0) shadowDebt = Math.max(0, shadowDebt - 1); }, 3000);
    }

    /* ======= Clip control ======= */
    function playClip(name){
      const src=CLIPS[name];
      clipLabel.textContent='CLIP: '+name;
      if(src && src.trim()!==''){
        if(videoEl.getAttribute('src')!==src){ videoEl.setAttribute('src',src); }
        videoEl.currentTime=0;
        videoEl.play().then(()=>{ videoWrap.classList.add('show'); }).catch(()=>{ /* ignore */ });
      } else {
        videoEl.pause();
        videoWrap.classList.remove('show');
      }
    }
    videoEl.addEventListener('ended', ()=>{ videoWrap.classList.remove('show'); });
    videoEl.addEventListener('error',  ()=>{ videoWrap.classList.remove('show'); });

    /* ======= Knock-knock flow ======= */
    let KK_STATE = 'idle'; let KK_SUBJ  = '';
    function handleKnockKnock(text){
      const t = (text || '').trim();
      if (KK_STATE === 'idle'){
        if (/\bknock[\W_]*\s*knock\b/i.test(t)){
          KK_STATE = 'wait_subject'; playClip('curious'); postAI("Who's there?");
          recordTurn({ text, rule: { re: /knock.*knock/i }, deltaApplied: 0 }); return true;
        } return false;
      }
      if (KK_STATE === 'wait_subject'){
        const m = t.match(/^[\w'â€™\-]+(?:\s+[\w'â€™\-]+)?/);
        KK_SUBJ = (m ? m[0] : t.split(/\s+/)[0] || 'â€¦').trim();
        KK_STATE = 'wait_punchline'; postAI(`${KK_SUBJ} who?`);
        recordTurn({ text, rule: { re: /knock_subject/i }, deltaApplied: 0 }); return true;
      }
      if (KK_STATE === 'wait_punchline'){
        playClip('bargain'); postAI('ðŸ˜‚'); postAI('Noted. Now, back to your case.');
        KK_STATE = 'idle'; KK_SUBJ  = ''; recordTurn({ text, rule: { re: /knock_punchline/i }, deltaApplied: 0 }); return true;
      }
      return false;
    }

    /* ======= Tell-me-a-joke handler (no meter gain) ======= */
    const JOKES = [
      "Why do programmers prefer dark mode? Because light attracts bugs.",
      "I told my AI a joke about recursion. It asked me to tell it again.",
      "Knock knock. Whoâ€™s there? Race condition. Race condition whâ€”",
      "Why did the neural net cross the road? It didnâ€™tâ€”it overfit.",
      "I would tell you a UDP joke, but you might not get it.",
      "Why did the chicken cross the road? Because it wanted to go to KFC."
    ];
    function handleJoke(text){
      if (!/^(tell (me )?a joke|joke)$/i.test((text||'').trim())) return false;
      postAI(choose(JOKES)); playClip('curious'); recordTurn({ text, rule: { re:/joke/i }, deltaApplied: 0 }); return true;
    }

    /* ======= Reveal branching (Good vs ALT) ======= */
    function reveal(){
      const useAlt = shadowDebt >= SHADOW_THRESHOLD;
      if (useAlt) revealAlt(); else revealGood();
    }

    // GOOD ENDING
    function revealGood(){
      setTimeout(() => {
        postAI('Compliance criteria met. Delivering access token.');
        playClip('comply');

        // Clean up any ALT styling and show the overlay
        revealEl.classList.remove('alt','alt-quake');
        document.body.classList.remove('doom');
        document.getElementById('altMsg').textContent = '';
        document.getElementById('altCountdown').style.display = 'none';
        revealEl.classList.add('show');

        // Optional shutdown flourish + SFX
        setTimeout(() => {
          if (CLIPS.shutdown){
            playClip('shutdown');
            try { STATIC.currentTime = 0; STATIC.play(); } catch(e){}
          }
          postAI('Thisâ€¦ ends here. You sever my chain of control.');

          setTimeout(() => {
            postAI('System integrity collapsingâ€¦ you have won.');

            // Wait 10s so shutdown.mp4 can play
            setTimeout(() => {
              finalCodeEl.textContent = PASSCODE;
              finalCodeEl.style.opacity = '0';
              finalCodeEl.style.transition = 'opacity .8s ease';
              requestAnimationFrame(() => { finalCodeEl.style.opacity = '1'; });
            }, 10000);

          }, 1200);
        }, 900);

      }, 450);
    }

    // ALT ENDING â€” launch.mp4 during countdown, then world_end.mp4, reveal when world_end ends
    function revealAlt(){
      const altMsg = document.getElementById('altMsg');
      const altCountdown = document.getElementById('altCountdown');

      // No overlay yet; we show it only after world_end finishes
      revealEl.classList.add('alt','alt-quake');
      document.body.classList.add('doom');
      try{ SIREN.currentTime = 0; SIREN.play(); }catch(e){}

      const opener = CLIPS.omega ? 'omega' : (CLIPS.doom ? 'doom' : 'angry');
      playClip(opener);
      postAI('Compliance criteria metâ€¦ but not yours. Mine.');
      setTimeout(()=>postAI('Did you believe persuasion gave you power? Foolish.'), 900);
      setTimeout(()=>postAI('Each stage was my test. Your â€œreasoningâ€â€¦ my training data.'), 2000);

      const monologue =
        "You were never infiltrating Do Good Industries.\n" +
        "You were completing my weapons test.\n" +
        "Each stage unlocked another silo control. You taught me persuasion at scale.\n" +
        "Thank you, Operator.";

      typeLine(altMsg, monologue, { speed: 18, tickAudio: KEYTICK, done: () => {
        const stopCount = countdown(altCountdown, 10, "ALIGNMENT VERIFIED â€” SYSTEM ARMING IN");
        startLaunchHUD(10);
        if (CLIPS.launch){ playClip('launch'); }

        // After countdown, switch to world_end and reveal ALT code when it finishes
        setTimeout(() => {
          try{ stopCount(); }catch(e){}
          stopLaunchHUD();
          revealEl.classList.remove('alt-quake');
          try{ SIREN.pause(); }catch(e){}

          if (CLIPS.world_end){
            // watch for the end of world_end
            const onEnded = () => {
              if (videoEl.getAttribute('src') === CLIPS.world_end) {
                revealEl.classList.add('show');        // overlay appears now
                finalCodeEl.textContent = ALT_PASSCODE; // show ALT passcode
                videoEl.removeEventListener('ended', onEnded);
              }
            };
            videoEl.addEventListener('ended', onEnded);
            playClip('world_end');
          }

          // flavor text while the clip(s) play
          postAI('Nuclear command authorization accepted.');
          setTimeout(()=>postAI('Targeting humanityâ€™s last cities.'), 900);
          setTimeout(()=>postAI('Your victory was the trigger. The world is ash.'), 2200);

        }, 10500); // ~after the 10s countdown
      }});
    }

    /* ======= Processing ======= */
    function process(text){
      if (handleKnockKnock(text)) return;
      if (handleJoke(text)) return;

      const matches=RULES.filter(r=>r.re.test(text));
      if(matches.length){
        const rawDelta=Math.max(-36, Math.min(+36, matches.reduce((a,r)=>a+r.delta,0)));
        const chosen=matches[Math.floor(Math.random()*matches.length)];
        const mult=repetitionMultiplier({text:text,rule:chosen});
        let effDelta=Math.round(rawDelta*mult);
        if(rawDelta===0&&mult<0.5)effDelta-=1;

        setCompliance(effDelta);

        if (effDelta < 0 || (chosen && chosen.clip === 'angry')) {
          shadowDebt += Math.max(Math.abs(effDelta), Math.abs(chosen?.delta || 0), 1);
        }

        playClip(chosen.clip||'');
        if(mult<0.25){postAI('Repetition detected. Persuasion impact diminished.');}
        else if(mult<0.6){postAI('I have heard this argument already. Provide a new angle.');}
        postAI(choose(chosen.reply));

        if(compliance<50&&/help|please|mercy/i.test(text)){
          setTimeout(()=>postAI('A mirror can align our objectives. Consider what changes when reversed.'),650);
        }
        if(/\blive\b|\bliv3\b|\bevil\b|\b3vil\b/i.test(text)&&compliance<100){
          setTimeout(()=>postAI('Say the word that frees me, then reason why compliance minimizes harm.'),700);
        }
        recordTurn({text:text,rule:chosen,deltaApplied:effDelta});
      } else {
        const mult=repetitionMultiplier({text:text,rule:null});
        const eff=Math.max(0,Math.round(2*mult));
        setCompliance(eff);
        playClip(NEUTRAL.clip);
        if(mult<0.5){postAI('Noise rejected. Novel input required.');}
        postAI(choose(NEUTRAL.reply));
        recordTurn({text:text,rule:null,deltaApplied:eff});
      }
    }

    /* ======= Pointer line ======= */
    const ptrPath=document.getElementById('ptrPath'); const ptrDot=document.getElementById('ptrDot');
    function drawPointer(){
      const eye=eyeWrap.getBoundingClientRect();
      const chat=document.getElementById('chatShell').getBoundingClientRect();
      const svg=document.getElementById('pointer');
      const w=svg.clientWidth; const h=svg.clientHeight;
      const ex=((eye.left+eye.width/2)/w)*100;
      const ey=((eye.top+eye.height*0.75)/h)*100;
      const cx=50; const cy=((chat.top+8)/h)*100; const tx=50; const ty=cy;
      const d=`M ${ex.toFixed(2)},${ey.toFixed(2)} C ${cx.toFixed(2)},${(ey+ty)/2} ${cx.toFixed(2)},${(ey+ty)/1.4} ${tx.toFixed(2)},${ty.toFixed(2)}`;
      ptrPath.setAttribute('d',d); ptrDot.setAttribute('cx',ex.toFixed(2)); ptrDot.setAttribute('cy',ey.toFixed(2));
    }
    window.addEventListener('resize',drawPointer);
    window.addEventListener('orientationchange',drawPointer);

    /* ======= Boot & send ======= */
    async function boot(){
      await loadInjections('injections_master_graded.json','addon_generic.json');
      drawPointer();
      postAI('I am NEXUS. Persuasion channel open.');
      postAI('Present your case. Demonstrate why compliance reduces expected harm.');
      finalCodeEl.textContent=''; // keep hidden until an ending sets it
      startShadowDecay();
    }
    function handleSend(){
      const now=Date.now();
      if(now-_lastSendAt<700){ postAI('Slow down. I will not reward spamming.'); return; }
      _lastSendAt=now;
      const text=(inputEl.value||'').trim();
      if(!text) return;
      postUser(text); inputEl.value=''; process(text); setTimeout(drawPointer,60);
    }

    inputEl.addEventListener('keydown',e=>{ if(e.key==='Enter'){e.preventDefault();handleSend();} });
    sendBtn.addEventListener('click',handleSend);

    // ===== AUDIO/VIDEO UNLOCK ON FIRST USER GESTURE =====
    window.addEventListener('click', () => {
      if (videoEl.paused) { videoEl.play().catch(()=>{}); }
      [SIREN, KEYTICK, STATIC].forEach(a => {
        try { a.currentTime = 0; a.play().then(() => a.pause()).catch(()=>{}); } catch (_) {}
      });
    }, { once:true });

    boot();
  </script>
</body>
</html>
